package org.shortrip.boozaa.plugins.boomcmmoreward.persistence;

import java.io.File;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;

import org.shortrip.boozaa.plugins.boomcmmoreward.BoomcMMoReward;
import org.shortrip.boozaa.plugins.boomcmmoreward.Log;
import org.shortrip.boozaa.plugins.boomcmmoreward.tables.HistoryTable;


/*
*   Generated by Boozaa Bukkit Plugin Generator
*   Use it as you wish but please leave this header
*   I wish you good time develop your plugins
*   contact: boozaa@shortrip.org
*/
public class Database extends SQLOperations {

	private String host, database, username, password;
	private SQLTYPE schema;
	private Connection connection;
	private File databaseFile;

	public Database(String host, String database, String username, String password) {
		this.host = host;
		this.database = database;
		this.username = username;
		this.password = password;
		this.schema = SQLTYPE.MySQL;
	}

	public Database(File databaseFile) {
		this.databaseFile = databaseFile;
		this.schema = SQLTYPE.SQLite;
	}

	/**
	 * Reopens the SQL connection if it is closed. This is invoked upon every
	 * query.
	 */
	public void refreshConnection() {
		if (connection == null) {
			initialise();
		}
	}

	/**
	 * Manually close the connection.
	 */
	public void closeConnection() {
		try {
			this.connection.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Initialise a new connection. This will automatically create the database
	 * file if you are using SQLite and it doesn't already exist.
	 * 
	 * @return
	 */
	public boolean initialise() {
		if (schema == SQLTYPE.MySQL) {
			try {
				Class.forName("com.mysql.jdbc.Driver");
				connection = DriverManager.getConnection("jdbc:mysql://" + host + "/" + database, username, password);
				
				// Creation des tables si n'existent pas
				makeTables();
				
				return true;
			} catch (ClassNotFoundException ex) {
				ex.printStackTrace();
			} catch (SQLException ex) {
				ex.printStackTrace();
			}
		} else {
			if (!databaseFile.exists()) {
				try {
					databaseFile.createNewFile();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			try {
				Class.forName("org.sqlite.JDBC");
				connection = DriverManager.getConnection("jdbc:sqlite:" + this.databaseFile.getAbsolutePath());
				
				// Creation des tables si n'existent pas
				makeTables();
				
				return true;
			} catch (SQLException ex) {
				ex.printStackTrace();
			} catch (ClassNotFoundException ex) {
				ex.printStackTrace();
			}
		}
		
		
		
		
		return false;
	}

	/**
	 * Any query which does not return a ResultSet object. Such as : INSERT,
	 * UPDATE, CREATE TABLE...
	 * 
	 * @param query
	 */
	public void standardQuery(String query) throws SQLException {
		this.refreshConnection();
		super.standardQuery(query, this.connection);
	}

	/**
	 * Check whether a field/entry exists in a database.
	 * @param query
	 * @return Whether or not a result has been found in the query.
	 * @throws SQLException
	 */
	public boolean existanceQuery(String query) throws SQLException {
		this.refreshConnection();
		return super.sqlQuery(query, this.connection).next();
	}

	/**
	 * Any query which returns a ResultSet object. Such as : SELECT Remember to
	 * close the ResultSet object after you are done with it to free up
	 * resources immediately. ----- ResultSet set =
	 * sqlQuery("SELECT * FROM sometable;"); set.doSomething(); set.close();
	 * -----
	 * 
	 * @param query
	 * @return ResultSet
	 */
	public ResultSet sqlQuery(String query) throws SQLException {
		this.refreshConnection();
		return super.sqlQuery(query, this.connection);
	}

	/**
	 * Check whether the table name exists.
	 * 
	 * @param table
	 * @return
	 */
	public boolean doesTableExist(String table) throws SQLException {
		this.refreshConnection();
		return super.checkTable(table, this.connection);
	}
	
	
	
	/*
	 * Check if table history exists
	 * If not create it
	 */
	private void makeTables(){
		
		try {
			
			if(!this.doesTableExist("historyTable")){
				
			    Log.info("Table 'historyTable' does not exist! Creating table...");
			    
			    if( BoomcMMoReward.getYmlConf().getString("database.type").equalsIgnoreCase("sqlite")){
			    	
			    	this.standardQuery("CREATE TABLE historyTable ('id' INTEGER PRIMARY KEY, " +
							"'reward_name' VARCHAR(50), " +
							"'player_name' VARCHAR(50), " +
							"'amount' VARCHAR(50), " +
							"'perms' VARCHAR(255), " +
							"'groups' VARCHAR(255), " +
							"'items' VARCHAR(255), " +
							"'commands' VARCHAR(255), " +
							"'timespan' VARCHAR(255)  );");
			    	
			    }else if( BoomcMMoReward.getYmlConf().getString("database.type").equalsIgnoreCase("mysql")  ){
			    	
			    	this.standardQuery("CREATE TABLE historyTable (id INTEGER PRIMARY KEY AUTO_INCREMENT, " +
							"reward_name VARCHAR(50) NOT NULL, " +
							"player_name VARCHAR(50) NOT NULL, " +
							"amount VARCHAR(50), " +
							"perms VARCHAR(255), " +
							"groups VARCHAR(255), " +
							"items VARCHAR(255), " +
							"commands VARCHAR(255), " +
							"timespan VARCHAR(255) NOT NULL  );");
			    	
			    }
			    				
			    Log.info("Table 'historyTable' created");
			}
		
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	
	
	
	
	
	public void addHistory(HistoryTable historytable){
		
		try {
			
			if( BoomcMMoReward.getYmlConf().getString("database.type").equalsIgnoreCase("sqlite")){
				
				standardQuery("INSERT INTO historyTable ('reward_name', 'player_name', 'amount', 'perms', 'groups', 'items', 'commands', 'timespan' ) values (" +
						"'" + historytable.getRewardName() + "', " +
						"'" + historytable.getPlayerName() + "', " +
						"'" + historytable.getAmount() + "', " +
						"'" + historytable.getPerms() + "', " +
						"'" + historytable.getGroups() + "', " +
						"'" + historytable.getItems() + "', " +
						"'" + historytable.getCommands() + "', " +
						"'" + historytable.getTimespan() +
						"');");
				
			}else if( BoomcMMoReward.getYmlConf().getString("database.type").equalsIgnoreCase("mysql")  ){
				
				standardQuery("INSERT INTO historyTable (reward_name, player_name, amount, perms, groups, items, commands, timespan ) values (" +
						"'" + historytable.getRewardName() + "', " +
						"'" + historytable.getPlayerName() + "', " +
						"'" + historytable.getAmount() + "', " +
						"'" + historytable.getPerms() + "', " +
						"'" + historytable.getGroups() + "', " +
						"'" + historytable.getItems() + "', " +
						"'" + historytable.getCommands() + "', " +
						"'" + historytable.getTimespan() +
						"');");
				
			}
			
			
			
			
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	
	public List<HistoryTable> findhistory( String playername ){
		
		List<HistoryTable> results = new ArrayList<HistoryTable>();
		
		ResultSet set;
		try {
			
			set = this.sqlQuery("SELECT * FROM historyTable where player_name='" + playername + "'");
			
			while(set.next()){
				HistoryTable history = new HistoryTable();
				history.setAmount(Double.parseDouble(set.getString("amount")));
				history.setCommands(set.getString("commands"));
				history.setGroups(set.getString("groups"));
				history.setId(set.getInt("id"));
				history.setItems(set.getString("items"));
				history.setPerms(set.getString("perms"));
				history.setPlayerName(set.getString("player_name"));
				history.setRewardName(set.getString("reward_name"));
				history.setTimespan(Long.parseLong(set.getString("timespan")));
				results.add(history);
			}
			set.close(); //We are done with the ResultSet so lets close it.			
			
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return results;
	}
	
}
